{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/dlarf1f.js","../lib/main.js","../lib/ndarray.js","../lib/index.js","../aff0384e85bc2871d4a13bf92c1240"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-len */\n\n// MODULES //\n\nimport { ndarray as iladlc } from '@stdlib/lapack-base-iladlc';\nimport { ndarray as iladlr } from '@stdlib/lapack-base-iladlr';\nimport { ndarray as dgemv } from '@stdlib/blas-base-dgemv';\nimport { ndarray as dger } from '@stdlib/blas-base-dger';\nimport { ndarray as daxpy } from '@stdlib/blas-base-daxpy';\nimport { ndarray as dscal } from '@stdlib/blas-base-dscal';\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether an operation should be applied to the left side.\n*\n* @private\n* @param {string} side - operation side\n* @returns {boolean} boolean indicating if an operation should be applied to the left side\n*/\nfunction isLeftSide( side ) {\n\treturn side === 'left';\n}\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @private\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tvar lastv;\n\tvar lastc;\n\tvar i;\n\n\tif ( tau === 0.0 ) {\n\t\treturn C;\n\t}\n\tlastc = 0;\n\tif ( isLeftSide( side ) ) {\n\t\tlastv = M;\n\t} else {\n\t\tlastv = N;\n\t}\n\t// Initialize `i` to point to the last element in `V`:\n\ti = offsetV + ( ( lastv-1 ) * strideV );\n\n\t// Move `i` to the last non-zero element in `V`, where we assume that V[0] = 1, and it is not stored, so we shouldn't access it...\n\twhile ( lastv > 0 && V[ i ] === 0.0 ) {\n\t\tlastv -= 1;\n\t\ti -= strideV;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Scan for the last non-zero column in `C`:\n\t\tlastc = iladlc( lastv + 1, N, C, strideC1, strideC2, offsetC ) + 1; // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t} else {\n\t\t// Scan for the last non-zero row in `C`:\n\t\tlastc = iladlr( M, lastv + 1, C, strideC1, strideC2, offsetC ) + 1; // // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t}\n\t// Return `C` unchanged if all elements in `C` are zero...\n\tif ( lastc === 0 ) {\n\t\treturn C;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Form: H*C\n\n\t\t// If `lastv = 1`, this means `V = 1`, so we just need to compute `C = H*C = (1-tau)*C`...\n\t\tif ( lastv === 0 ) {\n\t\t\t// C[0,0:lastc] = (1-tau)*C[0,0:lastc]\n\t\t\tdscal( lastc, 1.0-tau, C, strideC2, offsetC ); // scale the first row\n\t\t} else {\n\t\t\t// work[0:lastc,0] = C[0:lastv,0:lastc]^T * V[0:lastv,0]\n\n\t\t\t// work[0:lastc,0] = C[1:lastv,0:lastc]^T * V[1:lastv,0]\n\t\t\tdgemv( 'transpose', lastv-1, lastc, 1.0, C, strideC1, strideC2, offsetC+strideC1, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t\t\t// work[0:lastc,0] += C[0,0:lastc]^T * V[0,0] = C[0,0:lastc]^T\n\t\t\tdaxpy( lastc, 1.0, C, strideC2, offsetC, work, strideWork, offsetWork ); // operates on the first row of C\n\n\t\t\t// C[0:lastv,0:lastc] = C[...] - ( tau * V[0:lastv,0] * work[0:lastc,0]^T)\n\n\t\t\t// C[0,0:lastc] = C[...] - ( tau * V[0,0] * work[0:lastc,0]^^T ) = C[...] - ( tau * work[0:lastc,0]^T )\n\t\t\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC2, offsetC ); // operates on the first row of C\n\n\t\t\t// C[1:lastv,0:lastc] = C[...] - ( tau * V[1:lastv,0] * work[0:lastc,0]^T )\n\t\t\tdger( lastv-1, lastc, -tau, V, strideV, offsetV+strideV, work, strideWork, offsetWork, C, strideC1, strideC2, offsetC+strideC1 );\n\t\t}\n\t\treturn C;\n\t}\n\t// side === 'right'\n\n\t// Form: C*H\n\n\t// If `N = 1`, then `V = 1`, so we just need to compute `C = CH = C*(1-tau)`...\n\tif ( lastv === 0 ) {\n\t\t// C[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\t\tdscal( lastc, 1.0-tau, C, strideC1, offsetC ); // scale the first column\n\t\treturn C;\n\t}\n\t// work[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\n\t// work[0:lastc,0] = C[0:lastc,1:lastv] * V[1:lastv,0]\n\tdgemv( 'no-transpose', lastc, lastv-1, 1.0, C, strideC1, strideC2, offsetC+strideC2, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t// work[0:lastc,0] += C[0:lastc,0] * V[0,0] = C[0:lastc,0]\n\tdaxpy( lastc, 1.0, C, strideC1, offsetC, work, strideWork, offsetWork ); // operates on the first column of C\n\n\t// C[0:lastc,0:lastv] = C[...] - ( tau * work[0:lastc,0] * V[0:lastv,0]^T )\n\n\t// C[0:lastc,0] = C[...] - ( tau * work[0:lastc,0] * V[0,0]^T ) = C[...] - ( tau * work[0:lastc,0] )\n\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC1, offsetC ); // operates on the first column of C\n\n\t// C[0:lastc,1:lastv] = C[...] - ( tau * work[0:lastc,0] * V[1:lastv]^T )\n\tdger( lastc, lastv-1, -tau, work, strideWork, offsetWork, V, strideV, offsetV+strideV, C, strideC1, strideC2, offsetC+strideC2 );\n\n\treturn C;\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isOperationSide from '@stdlib/blas-base-assert-is-operation-side';\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray-base-assert-is-column-major-string';\nimport operationSides from '@stdlib/blas-base-operation-sides';\nimport join from '@stdlib/array-base-join';\nimport max from '@stdlib/math-base-special-max';\nimport stride2offset from '@stdlib/strided-base-stride2offset';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} order - storage layout\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {PositiveInteger} LDC - stride of the first dimension of `C` (a.k.a., leading dimension of the matrix `C`)\n* @param {Float64Array} work - workspace array\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid side\n* @throws {RangeError} ninth argument must be greater than or equal to max(1,N)\n* @throws {RangeError} sixth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( order, side, M, N, V, strideV, tau, C, LDC, work ) {\n\tvar sc1;\n\tvar sc2;\n\tvar ov;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'nullDQ', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\tif ( isRowMajor( order ) && LDC < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Ninth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDC ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsc1 = 1;\n\t\tsc2 = LDC;\n\t} else { // order === 'row-major'\n\t\tsc1 = LDC;\n\t\tsc2 = 1;\n\t}\n\tif ( side === 'left' ) {\n\t\tov = stride2offset( M, strideV );\n\t} else {\n\t\tov = stride2offset( N, strideV );\n\t}\n\treturn base( side, M, N, V, strideV, ov, tau, C, sc1, sc2, 0, work, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport dlarf1f from './dlarf1f.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( dlarf1f, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport isOperationSide from '@stdlib/blas-base-assert-is-operation-side';\nimport operationSides from '@stdlib/blas-base-operation-sides';\nimport join from '@stdlib/array-base-join';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @throws {TypeError} first argument must be a valid side\n* @throws {RangeError} fifth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be one of the following: \"%s\". Value: `%s`.', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\treturn base( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork );\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to apply a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* @module @stdlib/lapack-base-dlarf1f\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import dlarf1f from '@stdlib/lapack-base-dlarf1f';\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils-try-require';\nimport isError from '@stdlib/assert-is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar dlarf1f;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlarf1f = main;\n} else {\n\tdlarf1f = tmp;\n}\n\n\n// EXPORTS //\n\nexport default dlarf1f;\n\n// exports: { \"ndarray\": \"dlarf1f.ndarray\" }\n","export default '/home/runner/work/lapack-base-dlarf1f/lapack-base-dlarf1f/lib'"],"names":["isLeftSide","side","dlarf1f","M","N","V","strideV","offsetV","tau","C","strideC1","strideC2","offsetC","work","strideWork","offsetWork","lastv","lastc","i","iladlc","iladlr","dscal","dgemv","daxpy","dger","order","LDC","sc1","sc2","isLayout","TypeError","format","isOperationSide","join","operationSides","RangeError","isRowMajor","max","isColumnMajor","base","stride2offset","setReadOnly","tmp","tryRequire","require$$0","dlarf1f$1","isError","main"],"mappings":"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"}