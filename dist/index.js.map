{
  "version": 3,
  "sources": ["../lib/base.js", "../lib/dlarf1f.js", "../lib/ndarray.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/* eslint-disable max-len */\n\n// MODULES //\n\nvar iladlc = require( '@stdlib/lapack-base-iladlc' ).ndarray;\nvar iladlr = require( '@stdlib/lapack-base-iladlr' ).ndarray;\nvar dgemv = require( '@stdlib/blas-base-dgemv' ).ndarray;\nvar dger = require( '@stdlib/blas-base-dger' ).ndarray;\nvar daxpy = require( '@stdlib/blas-base-daxpy' ).ndarray;\nvar dscal = require( '@stdlib/blas-base-dscal' ).ndarray;\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether an operation should be applied to the left side.\n*\n* @private\n* @param {string} side - operation side\n* @returns {boolean} boolean indicating if an operation should be applied to the left side\n*/\nfunction isLeftSide( side ) {\n\treturn side === 'left';\n}\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @private\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tvar lastv;\n\tvar lastc;\n\tvar i;\n\n\tif ( tau === 0.0 ) {\n\t\treturn C;\n\t}\n\tlastc = 0;\n\tif ( isLeftSide( side ) ) {\n\t\tlastv = M;\n\t} else {\n\t\tlastv = N;\n\t}\n\t// Initialize `i` to point to the last element in `V`:\n\ti = offsetV + ( ( lastv-1 ) * strideV );\n\n\t// Move `i` to the last non-zero element in `V`, where we assume that V[0] = 1, and it is not stored, so we shouldn't access it...\n\twhile ( lastv > 0 && V[ i ] === 0.0 ) {\n\t\tlastv -= 1;\n\t\ti -= strideV;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Scan for the last non-zero column in `C`:\n\t\tlastc = iladlc( lastv + 1, N, C, strideC1, strideC2, offsetC ) + 1; // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t} else {\n\t\t// Scan for the last non-zero row in `C`:\n\t\tlastc = iladlr( M, lastv + 1, C, strideC1, strideC2, offsetC ) + 1; // // adjust by `+1` to account for the difference between zero-based and one-based indexing\n\t}\n\t// Return `C` unchanged if all elements in `C` are zero...\n\tif ( lastc === 0 ) {\n\t\treturn C;\n\t}\n\tif ( isLeftSide( side ) ) {\n\t\t// Form: H*C\n\n\t\t// If `lastv = 1`, this means `V = 1`, so we just need to compute `C = H*C = (1-tau)*C`...\n\t\tif ( lastv === 0 ) {\n\t\t\t// C[0,0:lastc] = (1-tau)*C[0,0:lastc]\n\t\t\tdscal( lastc, 1.0-tau, C, strideC2, offsetC ); // scale the first row\n\t\t} else {\n\t\t\t// work[0:lastc,0] = C[0:lastv,0:lastc]^T * V[0:lastv,0]\n\n\t\t\t// work[0:lastc,0] = C[1:lastv,0:lastc]^T * V[1:lastv,0]\n\t\t\tdgemv( 'transpose', lastv-1, lastc, 1.0, C, strideC1, strideC2, offsetC+strideC1, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t\t\t// work[0:lastc,0] += C[0,0:lastc]^T * V[0,0] = C[0,0:lastc]^T\n\t\t\tdaxpy( lastc, 1.0, C, strideC2, offsetC, work, strideWork, offsetWork ); // operates on the first row of C\n\n\t\t\t// C[0:lastv,0:lastc] = C[...] - ( tau * V[0:lastv,0] * work[0:lastc,0]^T)\n\n\t\t\t// C[0,0:lastc] = C[...] - ( tau * V[0,0] * work[0:lastc,0]^^T ) = C[...] - ( tau * work[0:lastc,0]^T )\n\t\t\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC2, offsetC ); // operates on the first row of C\n\n\t\t\t// C[1:lastv,0:lastc] = C[...] - ( tau * V[1:lastv,0] * work[0:lastc,0]^T )\n\t\t\tdger( lastv-1, lastc, -tau, V, strideV, offsetV+strideV, work, strideWork, offsetWork, C, strideC1, strideC2, offsetC+strideC1 );\n\t\t}\n\t\treturn C;\n\t}\n\t// side === 'right'\n\n\t// Form: C*H\n\n\t// If `N = 1`, then `V = 1`, so we just need to compute `C = CH = C*(1-tau)`...\n\tif ( lastv === 0 ) {\n\t\t// C[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\t\tdscal( lastc, 1.0-tau, C, strideC1, offsetC ); // scale the first column\n\t\treturn C;\n\t}\n\t// work[0:lastc,0] = ( 1-tau ) * C[0:lastc,0]\n\n\t// work[0:lastc,0] = C[0:lastc,1:lastv] * V[1:lastv,0]\n\tdgemv( 'no-transpose', lastc, lastv-1, 1.0, C, strideC1, strideC2, offsetC+strideC2, V, strideV, offsetV+strideV, 0.0, work, strideWork, offsetWork );\n\n\t// work[0:lastc,0] += C[0:lastc,0] * V[0,0] = C[0:lastc,0]\n\tdaxpy( lastc, 1.0, C, strideC1, offsetC, work, strideWork, offsetWork ); // operates on the first column of C\n\n\t// C[0:lastc,0:lastv] = C[...] - ( tau * work[0:lastc,0] * V[0:lastv,0]^T )\n\n\t// C[0:lastc,0] = C[...] - ( tau * work[0:lastc,0] * V[0,0]^T ) = C[...] - ( tau * work[0:lastc,0] )\n\tdaxpy( lastc, -tau, work, strideWork, offsetWork, C, strideC1, offsetC ); // operates on the first column of C\n\n\t// C[0:lastc,1:lastv] = C[...] - ( tau * work[0:lastc,0] * V[1:lastv]^T )\n\tdger( lastc, lastv-1, -tau, work, strideWork, offsetWork, V, strideV, offsetV+strideV, C, strideC1, strideC2, offsetC+strideC2 );\n\n\treturn C;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dlarf1f;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isOperationSide = require( '@stdlib/blas-base-assert-is-operation-side' );\nvar isLayout = require( '@stdlib/blas-base-assert-is-layout' );\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major-string' );\nvar isColumnMajor = require( '@stdlib/ndarray-base-assert-is-column-major-string' );\nvar operationSides = require( '@stdlib/blas-base-operation-sides' );\nvar join = require( '@stdlib/array-base-join' );\nvar max = require( '@stdlib/math-base-special-max' );\nvar stride2offset = require( '@stdlib/strided-base-stride2offset' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} order - storage layout\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {PositiveInteger} LDC - stride of the first dimension of `C` (a.k.a., leading dimension of the matrix `C`)\n* @param {Float64Array} work - workspace array\n* @throws {TypeError} first argument must be a valid order\n* @throws {TypeError} second argument must be a valid side\n* @throws {RangeError} ninth argument must be greater than or equal to max(1,N)\n* @throws {RangeError} sixth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( order, side, M, N, V, strideV, tau, C, LDC, work ) {\n\tvar sc1;\n\tvar sc2;\n\tvar ov;\n\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be one of the following: \"%s\". Value: `%s`.', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Sixth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\tif ( isRowMajor( order ) && LDC < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Ninth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDC ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsc1 = 1;\n\t\tsc2 = LDC;\n\t} else { // order === 'row-major'\n\t\tsc1 = LDC;\n\t\tsc2 = 1;\n\t}\n\tif ( side === 'left' ) {\n\t\tov = stride2offset( M, strideV );\n\t} else {\n\t\tov = stride2offset( N, strideV );\n\t}\n\treturn base( side, M, N, V, strideV, ov, tau, C, sc1, sc2, 0, work, 1, 0 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dlarf1f;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nvar isOperationSide = require( '@stdlib/blas-base-assert-is-operation-side' );\nvar operationSides = require( '@stdlib/blas-base-operation-sides' );\nvar join = require( '@stdlib/array-base-join' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Applies a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* ## Notes\n*\n* -   If `side = 'left'`,\n*\n*     -   `work` should have `N` indexed elements.\n*     -   `V` should have `1 + (M-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `H * C`.\n*\n* -   If `side = 'right'`,\n*\n*     -   `work` should have `M` indexed elements.\n*     -   `V` should have `1 + (N-1) * abs(strideV)` indexed elements.\n*     -   `C` is overwritten by `C * H`.\n*\n* @param {string} side - specifies the side of multiplication with `C`\n* @param {NonNegativeInteger} M - number of rows in `C`\n* @param {NonNegativeInteger} N - number of columns in `C`\n* @param {Float64Array} V - the vector `v`\n* @param {integer} strideV - stride length for `V`\n* @param {NonNegativeInteger} offsetV - starting index for `V`\n* @param {number} tau - scalar constant\n* @param {Float64Array} C - input matrix\n* @param {integer} strideC1 - stride of the first dimension of `C`\n* @param {integer} strideC2 - stride of the second dimension of `C`\n* @param {NonNegativeInteger} offsetC - starting index for `C`\n* @param {Float64Array} work - workspace array\n* @param {integer} strideWork - stride length for `work`\n* @param {NonNegativeInteger} offsetWork - starting index for `work`\n* @throws {TypeError} first argument must be a valid side\n* @throws {RangeError} fifth argument must not be zero\n* @returns {Float64Array} `C * H` or `H * C`\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'left', 4, 3, V, 1, 0, 1.0, C, 3, 1, 0, work, 1, 0 );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\nfunction dlarf1f( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork ) { // eslint-disable-line max-params\n\tif ( !isOperationSide( side ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be one of the following: \"%s\". Value: `%s`.', join( operationSides(), '\", \"' ), side ) );\n\t}\n\tif ( strideV === 0 ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be non-zero. Value: `%s`.', strideV ) );\n\t}\n\treturn base( side, M, N, V, strideV, offsetV, tau, C, strideC1, strideC2, offsetC, work, strideWork, offsetWork );\n}\n\n\n// EXPORTS //\n\nmodule.exports = dlarf1f;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar dlarf1f = require( './dlarf1f.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( dlarf1f, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = dlarf1f;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to apply a real elementary reflector `H = I - tau * v * v^T` to a real M by N matrix `C`.\n*\n* @module @stdlib/lapack-base-dlarf1f\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var dlarf1f = require( '@stdlib/lapack-base-dlarf1f' );\n*\n* var C = new Float64Array( [ 1.0, 5.0, 9.0, 2.0, 6.0, 10.0, 3.0, 7.0, 11.0, 4.0, 8.0, 12.0 ] );\n* var V = new Float64Array( [ 0.5, 0.5, 0.5, 0.5 ] );\n* var work = new Float64Array( 3 );\n*\n* var out = dlarf1f( 'row-major', 'left', 4, 3, V, 1, 1.0, C, 3, work );\n* // returns <Float64Array>[ -4.5, -10.5, -16.5, -0.75, -1.75, -2.75, 0.25, -0.75, -1.75, 1.25,  0.25, -0.75 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar dlarf1f;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tdlarf1f = main;\n} else {\n\tdlarf1f = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = dlarf1f;\n\n// exports: { \"ndarray\": \"dlarf1f.ndarray\" }\n"],
  "mappings": "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",
  "names": ["require_base", "__commonJSMin", "exports", "module", "iladlc", "iladlr", "dgemv", "dger", "daxpy", "dscal", "isLeftSide", "side", "dlarf1f", "M", "N", "V", "strideV", "offsetV", "tau", "C", "strideC1", "strideC2", "offsetC", "work", "strideWork", "offsetWork", "lastv", "lastc", "i", "require_dlarf1f", "__commonJSMin", "exports", "module", "isOperationSide", "isLayout", "isRowMajor", "isColumnMajor", "operationSides", "join", "max", "stride2offset", "format", "base", "dlarf1f", "order", "side", "M", "N", "V", "strideV", "tau", "C", "LDC", "work", "sc1", "sc2", "ov", "require_ndarray", "__commonJSMin", "exports", "module", "isOperationSide", "operationSides", "join", "format", "base", "dlarf1f", "side", "M", "N", "V", "strideV", "offsetV", "tau", "C", "strideC1", "strideC2", "offsetC", "work", "strideWork", "offsetWork", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "dlarf1f", "ndarray", "join", "tryRequire", "isError", "main", "dlarf1f", "tmp"]
}
